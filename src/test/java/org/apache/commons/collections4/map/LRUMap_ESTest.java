/*
 * This file was automatically generated by EvoSuite
 * Wed Oct 16 05:42:01 GMT 2019
 */

package org.apache.commons.collections4.map;

import org.junit.Test;
import static org.junit.Assert.*;
import static org.evosuite.shaded.org.mockito.Mockito.*;
import static org.evosuite.runtime.EvoAssertions.*;
import java.io.BufferedOutputStream;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.PushbackInputStream;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.function.BiFunction;
import org.apache.commons.collections4.map.AbstractHashedMap;
import org.apache.commons.collections4.map.AbstractLinkedMap;
import org.apache.commons.collections4.map.LRUMap;
import org.evosuite.runtime.EvoRunner;
import org.evosuite.runtime.EvoRunnerParameters;
import org.evosuite.runtime.ViolatedAssumptionAnswer;
import org.evosuite.runtime.mock.java.io.MockFile;
import org.evosuite.runtime.mock.java.io.MockFileInputStream;
import org.evosuite.runtime.mock.java.io.MockFileOutputStream;
import org.evosuite.runtime.mock.java.io.MockPrintStream;
import org.evosuite.runtime.mock.java.io.MockRandomAccessFile;
import org.evosuite.runtime.testdata.EvoSuiteFile;
import org.evosuite.runtime.testdata.FileSystemHandling;
import org.junit.runner.RunWith;

@RunWith(EvoRunner.class) @EvoRunnerParameters(mockJVMNonDeterminism = true, useVFS = true, useVNET = true, resetStaticState = true, separateClassLoader = false, useJEE = true) 
public class LRUMap_ESTest extends LRUMap_ESTest_scaffolding {

  @Test(timeout = 4000)
  public void test00()  throws Throwable  {
      int int0 = 901;
      float float0 = 1455.31F;
      LRUMap<Integer, String> lRUMap0 = new LRUMap<Integer, String>(901, 901, 1455.31F);
      AbstractLinkedMap.LinkEntry<Integer, String> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      lRUMap0.init();
      lRUMap0.updateEntry(abstractLinkedMap_LinkEntry0, "");
      float float1 = (-190.334F);
      LRUMap<Integer, Integer> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<Integer, Integer>(901, (-190.334F), true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test01()  throws Throwable  {
      LRUMap<String, MockFileInputStream> lRUMap0 = new LRUMap<String, MockFileInputStream>(1073741824, 1.0F, true);
  }

  @Test(timeout = 4000)
  public void test02()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object> lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object>(581);
      lRUMap0.maxSize();
      LRUMap<InputStream, String> lRUMap1 = new LRUMap<InputStream, String>(581, false);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      AbstractHashedMap.HashEntry<InputStream, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<InputStream, String>(abstractLinkedMap_LinkEntry0, 1601, abstractLinkedMap_LinkEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry1 = new AbstractLinkedMap.LinkEntry<InputStream, String>(abstractHashedMap_HashEntry0, 2099, abstractHashedMap_HashEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry2 = abstractLinkedMap_LinkEntry1.after;
      lRUMap1.removeLRU((AbstractLinkedMap.LinkEntry<InputStream, String>) null);
      LRUMap<InputStream, MockFileInputStream> lRUMap2 = new LRUMap<InputStream, MockFileInputStream>();
      LRUMap<InputStream, MockFileInputStream> lRUMap3 = new LRUMap<InputStream, MockFileInputStream>(581, true);
      lRUMap3.size = 342;
      AbstractHashedMap.HashEntry<InputStream, MockFileInputStream> abstractHashedMap_HashEntry1 = new AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>((AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>) null, 581, (Object) null, (MockFileInputStream) null);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream> abstractLinkedMap_LinkEntry3 = new AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream>(abstractHashedMap_HashEntry1, 1078, abstractHashedMap_HashEntry0, mockFileInputStream0);
      // Undeclared exception!
      try { 
        lRUMap3.reuseMapping(abstractLinkedMap_LinkEntry3, 792, 2099, mockFileInputStream0, (MockFileInputStream) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=org.evosuite.runtime.mock.java.io.MockFileInputStream@30681472 value=null size=342 maxSize=581 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test03()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      lRUMap0.entrySet();
      Integer integer0 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer0);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      int int0 = 45;
      lRUMap1.clone();
      Integer integer1 = new Integer((-1747));
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), 45, (Object) null, integer1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test04()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object> lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object>(581);
      lRUMap0.maxSize();
      LRUMap<InputStream, String> lRUMap1 = new LRUMap<InputStream, String>(581, false);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      AbstractHashedMap.HashEntry<InputStream, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<InputStream, String>(abstractLinkedMap_LinkEntry0, 1601, abstractLinkedMap_LinkEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry1 = new AbstractLinkedMap.LinkEntry<InputStream, String>(abstractHashedMap_HashEntry0, 2099, abstractHashedMap_HashEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry2 = abstractLinkedMap_LinkEntry1.after;
      lRUMap1.removeLRU((AbstractLinkedMap.LinkEntry<InputStream, String>) null);
      LRUMap<InputStream, MockFileInputStream> lRUMap2 = new LRUMap<InputStream, MockFileInputStream>();
      LRUMap<InputStream, MockFileInputStream> lRUMap3 = new LRUMap<InputStream, MockFileInputStream>(581, true);
      AbstractHashedMap.HashEntry<InputStream, MockFileInputStream> abstractHashedMap_HashEntry1 = new AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>((AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>) null, 581, (Object) null, (MockFileInputStream) null);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream> abstractLinkedMap_LinkEntry3 = new AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream>(abstractHashedMap_HashEntry1, 1078, abstractHashedMap_HashEntry0, mockFileInputStream0);
      // Undeclared exception!
      try { 
        lRUMap3.reuseMapping(abstractLinkedMap_LinkEntry3, 792, 2099, mockFileInputStream0, (MockFileInputStream) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=org.evosuite.runtime.mock.java.io.MockFileInputStream@2a7d8b69 value=null size=0 maxSize=581 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test05()  throws Throwable  {
      LRUMap<Integer, LRUMap<Integer, InputStream>> lRUMap0 = new LRUMap<Integer, LRUMap<Integer, InputStream>>(1, 1, 480.0F);
      LRUMap<Integer, LRUMap<Integer, InputStream>> lRUMap1 = lRUMap0.clone();
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      LRUMap<Integer, InputStream> lRUMap2 = new LRUMap<Integer, InputStream>(1073741824, 2620);
      AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>>((AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>>) null, 1, lRUMap1, lRUMap2);
      Integer integer0 = new Integer(2620);
      PushbackInputStream pushbackInputStream0 = new PushbackInputStream((InputStream) null, 2620);
      lRUMap2.addMapping(0, 1073741824, integer0, pushbackInputStream0);
      LRUMap<Integer, InputStream> lRUMap3 = lRUMap2.clone();
      AbstractLinkedMap.LinkEntry<Integer, LRUMap<Integer, InputStream>> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<Integer, LRUMap<Integer, InputStream>>(abstractHashedMap_HashEntry0, 1073741824, lRUMap2, lRUMap3);
      // Undeclared exception!
      try { 
        lRUMap1.moveToMRU(abstractLinkedMap_LinkEntry0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test06()  throws Throwable  {
      int int0 = 901;
      float float0 = 1455.31F;
      LRUMap<Integer, String> lRUMap0 = new LRUMap<Integer, String>(901, 901, 1455.31F);
      AbstractLinkedMap.LinkEntry<Integer, String> abstractLinkedMap_LinkEntry0 = lRUMap0.header;
      // Undeclared exception!
      try { 
        lRUMap0.updateEntry(abstractLinkedMap_LinkEntry0, "");
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Can't move header to MRU This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test07()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      int int0 = (-1747);
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      Integer integer0 = new Integer(871);
      abstractHashedMap0.put((Object) null, integer0);
      lRUMap0.entrySet();
      Integer integer1 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer1);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      // Undeclared exception!
      try { 
        lRUMap1.addMapping(871, (-1747), integer1, integer0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 871
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test08()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      lRUMap0.entrySet();
      Integer integer0 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer0);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      Object object0 = new Object();
      Integer integer1 = new Integer(45);
      BiFunction<Integer, Integer, Integer> biFunction0 = (BiFunction<Integer, Integer, Integer>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      lRUMap1.merge(object0, integer1, biFunction0);
      Integer integer2 = new Integer((-1747));
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), 45, (Object) null, integer2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test09()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      lRUMap0.get(lRUMap0);
      lRUMap0.put(lRUMap0, (Integer) null);
      lRUMap0.entrySet();
      Integer integer0 = new Integer((-1747));
      lRUMap0.put(lRUMap0, integer0);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(lRUMap0, false);
      Integer integer1 = new Integer((-1747));
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), 45, (Object) null, integer1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test10()  throws Throwable  {
      int int0 = 300;
      LRUMap<String, Object> lRUMap0 = new LRUMap<String, Object>(300);
      LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Integer> lRUMap1 = new LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Integer>(300);
      boolean boolean0 = false;
      lRUMap1.get((Object) null, false);
      LRUMap<Object, LRUMap<Integer, Integer>> lRUMap2 = new LRUMap<Object, LRUMap<Integer, Integer>>(300, 0.75F, true);
      lRUMap2.loadFactor = 0.0F;
      lRUMap2.maxSize();
      LRUMap<LRUMap<Object, String>, String> lRUMap3 = new LRUMap<LRUMap<Object, String>, String>(300, false);
      BiFunction<Object, String, String> biFunction0 = (BiFunction<Object, String, String>) mock(BiFunction.class, new ViolatedAssumptionAnswer());
      boolean boolean1 = true;
      LRUMap<Integer, InputStream> lRUMap4 = new LRUMap<Integer, InputStream>(1520, 300);
      Object object0 = AbstractHashedMap.NULL;
      byte[] byteArray0 = new byte[7];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte) (-29);
      byteArray0[2] = (byte)40;
      byteArray0[3] = (byte) (-72);
      byteArray0[4] = (byte)31;
      byteArray0[5] = (byte) (-80);
      byteArray0[6] = (byte)68;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      AbstractLinkedMap.LinkEntry<Integer, InputStream> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<Integer, InputStream>((AbstractHashedMap.HashEntry<Integer, InputStream>) null, 300, object0, byteArrayInputStream0);
      // Undeclared exception!
      try { 
        lRUMap4.updateEntry(abstractLinkedMap_LinkEntry0, byteArrayInputStream0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test11()  throws Throwable  {
      LRUMap<InputStream, Integer> lRUMap0 = new LRUMap<InputStream, Integer>();
      lRUMap0.createValuesIterator();
      lRUMap0.createValuesIterator();
      LRUMap<Object, String> lRUMap1 = new LRUMap<Object, String>(12, false);
      lRUMap1.size = 12;
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)20;
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-38);
      byteArray0[3] = (byte)37;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      lRUMap0.put(byteArrayInputStream0, (Integer) null);
      lRUMap1.isFull();
      lRUMap0.get((Object) "", false);
      LRUMap<MockFileInputStream, InputStream> lRUMap2 = new LRUMap<MockFileInputStream, InputStream>(786);
      LRUMap<MockFileInputStream, InputStream> lRUMap3 = null;
      try {
        lRUMap3 = new LRUMap<MockFileInputStream, InputStream>(lRUMap2, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test12()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>();
      lRUMap0.createEntrySetIterator();
      int int0 = 1073741824;
      LRUMap<Object, String> lRUMap1 = new LRUMap<Object, String>(1073741824, true);
  }

  @Test(timeout = 4000)
  public void test13()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      int int0 = (-1747);
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      lRUMap0.entrySet();
      Integer integer0 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer0);
      boolean boolean0 = true;
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      Integer integer1 = new Integer((-1747));
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), 45, (Object) null, integer1);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test14()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      int int0 = (-1747);
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      lRUMap0.entrySet();
      Integer integer0 = new Integer((-1747));
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      abstractHashedMap0.put(lRUMap0, integer0);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      lRUMap1.entrySet();
      float float0 = 0.0F;
      LRUMap<Integer, String> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<Integer, String>((-1747), 0.0F, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test15()  throws Throwable  {
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "No next() entry in the iteration");
      LRUMap<LRUMap<Object, Object>, String> lRUMap0 = new LRUMap<LRUMap<Object, Object>, String>(682, 16, 16);
      LRUMap<String, Integer> lRUMap1 = new LRUMap<String, Integer>(16, 682, false);
      Integer integer0 = new Integer(682);
      AbstractHashedMap.HashEntry<String, Integer> abstractHashedMap_HashEntry0 = lRUMap1.createEntry((AbstractHashedMap.HashEntry<String, Integer>) null, 682, "No next() entry in the iteration", integer0);
      AbstractLinkedMap.LinkEntry<String, Integer> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, Integer>(abstractHashedMap_HashEntry0, (-1363), lRUMap1, integer0);
      Integer integer1 = new Integer((-1363));
      AbstractHashedMap.HashEntry<String, Integer> abstractHashedMap_HashEntry1 = new AbstractHashedMap.HashEntry<String, Integer>(abstractLinkedMap_LinkEntry0, 1016, "No next() entry in the iteration", integer1);
      Integer integer2 = new Integer(0);
      // Undeclared exception!
      try { 
        lRUMap1.updateEntry(abstractHashedMap_HashEntry1, integer2);
        fail("Expecting exception: ClassCastException");
      
      } catch(ClassCastException e) {
         //
         // org.apache.commons.collections4.map.AbstractHashedMap$HashEntry cannot be cast to org.apache.commons.collections4.map.AbstractLinkedMap$LinkEntry
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test16()  throws Throwable  {
      LRUMap<InputStream, Integer> lRUMap0 = new LRUMap<InputStream, Integer>();
      lRUMap0.createValuesIterator();
      lRUMap0.createValuesIterator();
      LRUMap<Object, String> lRUMap1 = new LRUMap<Object, String>(12, false);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)20;
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-38);
      byteArray0[3] = (byte)37;
      lRUMap0.modCount = 10;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      byteArrayInputStream0.skip((byte) (-38));
      lRUMap0.put(byteArrayInputStream0, (Integer) null);
      boolean boolean0 = lRUMap1.isFull();
      assertFalse(boolean0);
      
      lRUMap0.get((Object) "", false);
      LRUMap<Object, Object> lRUMap2 = new LRUMap<Object, Object>((byte)20, false);
      LRUMap<Integer, Object> lRUMap3 = new LRUMap<Integer, Object>();
      LRUMap<Integer, Object> lRUMap4 = lRUMap3.clone();
      lRUMap2.get((Object) lRUMap4, false);
      assertEquals(20, lRUMap2.maxSize());
      assertFalse(lRUMap2.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test17()  throws Throwable  {
      FileSystemHandling fileSystemHandling0 = new FileSystemHandling();
      LRUMap<MockFileInputStream, String> lRUMap0 = new LRUMap<MockFileInputStream, String>(1962, false);
      Integer integer0 = new Integer(1962);
      lRUMap0.get((Object) integer0);
      LRUMap<Object, InputStream> lRUMap1 = new LRUMap<Object, InputStream>(1958, 1958, false);
      byte[] byteArray0 = new byte[9];
      byteArray0[0] = (byte)0;
      byteArray0[1] = (byte)38;
      byteArray0[2] = (byte)0;
      byteArray0[3] = (byte) (-117);
      byteArray0[4] = (byte)103;
      byteArray0[5] = (byte)123;
      byteArray0[6] = (byte)100;
      byteArray0[7] = (byte) (-1);
      byteArray0[8] = (byte) (-46);
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      // Undeclared exception!
      try { 
        lRUMap1.addMapping(2494, 3494, lRUMap0, byteArrayInputStream0);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // 2494
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test18()  throws Throwable  {
      LRUMap<MockFileInputStream, String> lRUMap0 = new LRUMap<MockFileInputStream, String>();
      HashMap<MockFileInputStream, String> hashMap0 = new HashMap<MockFileInputStream, String>();
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      hashMap0.put(mockFileInputStream0, "");
      lRUMap0.putAll(hashMap0);
      lRUMap0.createKeySetIterator();
      lRUMap0.remove("");
      lRUMap0.get((Object) "", false);
      int int0 = 1749;
      LRUMap<LRUMap<Object, Integer>, Object> lRUMap1 = new LRUMap<LRUMap<Object, Integer>, Object>(1749, 1749, 1749);
      LRUMap<Object, String> lRUMap2 = new LRUMap<Object, String>(lRUMap0);
      LRUMap<Object, Object> lRUMap3 = new LRUMap<Object, Object>(1749, 0.75F);
      lRUMap2.get((Object) lRUMap3, false);
      int int1 = (-1792);
      Integer integer0 = new Integer((-757));
      LRUMap<Integer, String> lRUMap4 = new LRUMap<Integer, String>();
      LRUMap<String, String> lRUMap5 = null;
      try {
        lRUMap5 = new LRUMap<String, String>((-1383), 1.0F, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test19()  throws Throwable  {
      LRUMap<MockFileInputStream, MockFileInputStream> lRUMap0 = new LRUMap<MockFileInputStream, MockFileInputStream>(96, 96);
      assertFalse(lRUMap0.isFull());
      
      lRUMap0.addMapping(96, 96, (MockFileInputStream) null, (MockFileInputStream) null);
      assertEquals(96, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test20()  throws Throwable  {
      int int0 = 1567;
      boolean boolean0 = true;
      LRUMap<String, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, Object>(0, 1567, 900.04F, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test21()  throws Throwable  {
      LRUMap<Integer, Object> lRUMap0 = new LRUMap<Integer, Object>(309, 309, 309, true);
      LRUMap<String, Integer> lRUMap1 = new LRUMap<String, Integer>();
      int int0 = (-409);
      AbstractHashedMap.HashEntry<String, Integer> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<String, Integer>((AbstractHashedMap.HashEntry<String, Integer>) null, (-409), "Load factor must be greater than 0", (Integer) null);
      AbstractLinkedMap.LinkEntry<String, Integer> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, Integer>(abstractHashedMap_HashEntry0, (-409), (Object) null, (Integer) null);
      abstractHashedMap_HashEntry0.equals("Load factor must be greater than 0");
      AbstractLinkedMap.LinkEntry<String, Integer> abstractLinkedMap_LinkEntry1 = abstractLinkedMap_LinkEntry0.after;
      lRUMap1.removeLRU((AbstractLinkedMap.LinkEntry<String, Integer>) null);
      int int1 = 0;
      LRUMap<Object, Object> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<Object, Object>(0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test22()  throws Throwable  {
      LRUMap<Integer, Integer> lRUMap0 = new LRUMap<Integer, Integer>(1, 0, 1, true);
      LRUMap<Integer, String> lRUMap1 = new LRUMap<Integer, String>(1, false);
      Integer integer0 = new Integer(0);
      lRUMap0.getOrDefault(lRUMap1, integer0);
      lRUMap0.header = null;
      lRUMap1.entrySet();
      LRUMap<Integer, Integer> lRUMap2 = lRUMap0.clone();
      String string0 = "/PJf#";
      lRUMap2.values();
      // Undeclared exception!
      try { 
        lRUMap0.destroyEntry((AbstractHashedMap.HashEntry<Integer, Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test23()  throws Throwable  {
      int int0 = 1073741824;
      LRUMap<String, LRUMap<InputStream, Object>> lRUMap0 = new LRUMap<String, LRUMap<InputStream, Object>>(1073741824, 1073741824);
  }

  @Test(timeout = 4000)
  public void test24()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(1073741824, 1073741824);
  }

  @Test(timeout = 4000)
  public void test25()  throws Throwable  {
      boolean boolean0 = false;
      LRUMap<Integer, InputStream> lRUMap0 = new LRUMap<Integer, InputStream>(1402, false);
      LRUMap<String, Integer> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<String, Integer>((Map<? extends String, ? extends Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test26()  throws Throwable  {
      HashMap<String, InputStream> hashMap0 = new HashMap<String, InputStream>();
      InputStream inputStream0 = null;
      hashMap0.put("Initial capacity must be a non negative number", (InputStream) null);
      hashMap0.put("Initial capacity must be a non negative number", (InputStream) null);
      LRUMap<String, InputStream> lRUMap0 = new LRUMap<String, InputStream>(hashMap0, true);
      int int0 = 0;
      LRUMap<String, String> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<String, String>(0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test27()  throws Throwable  {
      LRUMap<Integer, MockFileInputStream> lRUMap0 = new LRUMap<Integer, MockFileInputStream>(1618, true);
      assertEquals(1618, lRUMap0.maxSize());
      assertTrue(lRUMap0.isScanUntilRemovable());
      
      int int0 = lRUMap0.maxSize();
      assertEquals(1618, int0);
      assertTrue(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test28()  throws Throwable  {
      int int0 = 1073741824;
      LRUMap<InputStream, Integer> lRUMap0 = new LRUMap<InputStream, Integer>(1073741824);
  }

  @Test(timeout = 4000)
  public void test29()  throws Throwable  {
      int int0 = 61;
      LRUMap<Object, LRUMap<Object, Object>> lRUMap0 = new LRUMap<Object, LRUMap<Object, Object>>(61);
      AbstractHashedMap.EntrySet<Object, LRUMap<Object, Object>> abstractHashedMap_EntrySet0 = new AbstractHashedMap.EntrySet<Object, LRUMap<Object, Object>>(lRUMap0);
      lRUMap0.entrySet = abstractHashedMap_EntrySet0;
      LRUMap<Object, LRUMap<Object, Object>> lRUMap1 = lRUMap0.clone();
      ObjectOutputStream objectOutputStream0 = null;
      // Undeclared exception!
      try { 
        lRUMap1.doWriteObject((ObjectOutputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test30()  throws Throwable  {
      LRUMap<MockFileInputStream, InputStream> lRUMap0 = new LRUMap<MockFileInputStream, InputStream>();
      MockPrintStream mockPrintStream0 = new MockPrintStream("reuse=null, header.after=");
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(mockPrintStream0);
      lRUMap0.doWriteObject(objectOutputStream0);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(100, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test31()  throws Throwable  {
      int int0 = 123;
      LRUMap<String, Integer> lRUMap0 = new LRUMap<String, Integer>(123, 123, 609.41F, true);
      int int1 = 1;
      lRUMap0.mapIterator();
      LRUMap<String, Object> lRUMap1 = new LRUMap<String, Object>(123, true);
      int int2 = (-4634);
      Integer integer0 = new Integer((-4634));
      lRUMap0.getOrDefault(lRUMap1, integer0);
      lRUMap0.ensureCapacity(1);
      LRUMap<String, Integer> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<String, Integer>(lRUMap0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test32()  throws Throwable  {
      LRUMap<Object, InputStream> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, InputStream>(1187, 1435, 1187, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap initial size must not be greather than max size
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test33()  throws Throwable  {
      LRUMap<LRUMap<String, Object>, Integer> lRUMap0 = new LRUMap<LRUMap<String, Object>, Integer>(1520, 1787.77F, true);
      LRUMap<AbstractLinkedMap.LinkEntry<Integer, String>, String> lRUMap1 = new LRUMap<AbstractLinkedMap.LinkEntry<Integer, String>, String>(1520, 1520, 180.12775F, true);
      boolean boolean0 = lRUMap1.isFull();
      assertFalse(boolean0);
      assertTrue(lRUMap1.isScanUntilRemovable());
      assertEquals(1520, lRUMap1.maxSize());
  }

  @Test(timeout = 4000)
  public void test34()  throws Throwable  {
      int int0 = 300;
      LRUMap<String, Object> lRUMap0 = new LRUMap<String, Object>(300);
      boolean boolean0 = false;
      LRUMap<Object, Object> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<Object, Object>(lRUMap0, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test35()  throws Throwable  {
      int int0 = 1854;
      LRUMap<String, Integer> lRUMap0 = new LRUMap<String, Integer>(1854, 1854);
      lRUMap0.init();
      int int1 = 0;
      LRUMap<Integer, Integer> lRUMap1 = new LRUMap<Integer, Integer>(1854, 0);
      lRUMap1.isScanUntilRemovable();
      int int2 = (-2950);
      int int3 = (-1710);
      Integer integer0 = new Integer((-299));
      // Undeclared exception!
      try { 
        lRUMap1.updateEntry((AbstractHashedMap.HashEntry<Integer, Integer>) null, integer0);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test36()  throws Throwable  {
      LRUMap<InputStream, AbstractLinkedMap.LinkEntry<String, String>> lRUMap0 = new LRUMap<InputStream, AbstractLinkedMap.LinkEntry<String, String>>(1402, true);
      lRUMap0.isScanUntilRemovable();
      LRUMap<Integer, MockFileInputStream> lRUMap1 = new LRUMap<Integer, MockFileInputStream>(1402, 1402);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      AbstractLinkedMap.LinkEntry<Integer, MockFileInputStream> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<Integer, MockFileInputStream>((AbstractHashedMap.HashEntry<Integer, MockFileInputStream>) null, (-100), lRUMap1, mockFileInputStream0);
      int int0 = 44;
      DataInputStream dataInputStream0 = new DataInputStream(mockFileInputStream0);
      ObjectInputStream objectInputStream0 = null;
      try {
        objectInputStream0 = new ObjectInputStream(dataInputStream0);
        fail("Expecting exception: IOException");
      
      } catch(Throwable e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.evosuite.runtime.mock.java.io.NativeMockedIO", e);
      }
  }

  @Test(timeout = 4000)
  public void test37()  throws Throwable  {
      LRUMap<String, Integer> lRUMap0 = new LRUMap<String, Integer>();
      int int0 = 3522;
      LRUMap<String, String> lRUMap1 = new LRUMap<String, String>(3522, 3522);
      AbstractHashedMap.HashEntry<String, String> abstractHashedMap_HashEntry0 = null;
      String string0 = "d+KNs|^-Ld:d";
      AbstractLinkedMap.LinkEntry<String, String> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<String, String>((AbstractHashedMap.HashEntry<String, String>) null, 3522, lRUMap1, "d+KNs|^-Ld:d");
      AbstractHashedMap.HashEntry<String, String> abstractHashedMap_HashEntry1 = abstractLinkedMap_LinkEntry0.next;
      abstractLinkedMap_LinkEntry0.next = null;
      // Undeclared exception!
      try { 
        lRUMap1.updateEntry((AbstractHashedMap.HashEntry<String, String>) null, "(U08s|=J");
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test38()  throws Throwable  {
      LRUMap<Object, String> lRUMap0 = new LRUMap<Object, String>();
      LRUMap<String, Integer> lRUMap1 = new LRUMap<String, Integer>();
      AbstractLinkedMap.LinkEntry<String, Integer> abstractLinkedMap_LinkEntry0 = null;
      // Undeclared exception!
      try { 
        lRUMap1.moveToMRU((AbstractLinkedMap.LinkEntry<String, Integer>) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test39()  throws Throwable  {
      int int0 = 0;
      LRUMap<AbstractLinkedMap.LinkEntry<Object, String>, Integer> lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<Object, String>, Integer>(976, 0);
      lRUMap0.modCount = 0;
      lRUMap0.clear();
      int int1 = 100;
      LRUMap<Object, MockFileInputStream> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<Object, MockFileInputStream>(0, 100);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test40()  throws Throwable  {
      LRUMap<String, InputStream> lRUMap0 = new LRUMap<String, InputStream>();
      LRUMap<InputStream, InputStream> lRUMap1 = new LRUMap<InputStream, InputStream>();
      lRUMap1.get((Object) lRUMap0, false);
      LRUMap<Integer, Integer> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<Integer, Integer>((-1), (-216.315F), false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test41()  throws Throwable  {
      int int0 = 204;
      LRUMap<Integer, Integer> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Integer, Integer>(204, (-182.57F));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test42()  throws Throwable  {
      int int0 = (-2181);
      boolean boolean0 = false;
      LRUMap<Object, Integer> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Integer>((-2181), (-2181), (-2181), false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test43()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(411);
      LRUMap<Object, Object> lRUMap1 = lRUMap0.clone();
      AbstractHashedMap.EntrySet<Object, Object> abstractHashedMap_EntrySet0 = new AbstractHashedMap.EntrySet<Object, Object>(lRUMap1);
      lRUMap1.entrySet = abstractHashedMap_EntrySet0;
      lRUMap1.get((Object) null);
      assertEquals(411, lRUMap1.maxSize());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test44()  throws Throwable  {
      int int0 = (-1526);
      LRUMap<Object, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, Object>((-1526), true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test45()  throws Throwable  {
      LRUMap<Integer, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Integer, String>((Map<? extends Integer, ? extends String>) null, false);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test46()  throws Throwable  {
      int int0 = 0;
      LRUMap<Object, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Object, String>(983, 0, 0.0F);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Load factor must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test47()  throws Throwable  {
      int int0 = (-3554);
      LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Integer> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Integer>((-3554));
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test48()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = new LRUMap<String, String>(3350);
      LRUMap<String, String> lRUMap1 = lRUMap0.clone();
      assertEquals(3350, lRUMap1.maxSize());
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test49()  throws Throwable  {
      int int0 = (-2977);
      boolean boolean0 = false;
      LRUMap<String, Object> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, Object>((-2977), 0.75F, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // Initial capacity must be a non negative number
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test50()  throws Throwable  {
      int int0 = 0;
      LRUMap<Integer, AbstractLinkedMap.LinkEntry<Object, Object>> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<Integer, AbstractLinkedMap.LinkEntry<Object, Object>>(0, 0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test51()  throws Throwable  {
      LRUMap<LRUMap<String, Object>, Object> lRUMap0 = new LRUMap<LRUMap<String, Object>, Object>();
      lRUMap0.maxSize();
      LRUMap<String, String> lRUMap1 = new LRUMap<String, String>(100, 100, 100, false);
      lRUMap1.maxSize();
      LRUMap<Integer, String> lRUMap2 = new LRUMap<Integer, String>(100, false);
      boolean boolean0 = false;
      LRUMap<Object, String> lRUMap3 = new LRUMap<Object, String>(100, 100, false);
      // Undeclared exception!
      try { 
        lRUMap3.doReadObject((ObjectInputStream) null);
        fail("Expecting exception: NullPointerException");
      
      } catch(NullPointerException e) {
         //
         // no message in exception (getMessage() returned null)
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test52()  throws Throwable  {
      LRUMap<Integer, MockFileInputStream> lRUMap0 = new LRUMap<Integer, MockFileInputStream>();
      int int0 = lRUMap0.maxSize();
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(100, int0);
  }

  @Test(timeout = 4000)
  public void test53()  throws Throwable  {
      LRUMap<Integer, Object> lRUMap0 = new LRUMap<Integer, Object>();
      lRUMap0.isFull();
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test54()  throws Throwable  {
      LRUMap<String, String> lRUMap0 = null;
      try {
        lRUMap0 = new LRUMap<String, String>(0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test55()  throws Throwable  {
      LRUMap<Object, Object> lRUMap0 = new LRUMap<Object, Object>(3978, 3978, 3978);
      assertFalse(lRUMap0.isScanUntilRemovable());
      assertEquals(3978, lRUMap0.maxSize());
  }

  @Test(timeout = 4000)
  public void test56()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      int int0 = (-1747);
      Integer integer0 = new Integer(432);
      abstractHashedMap0.put(lRUMap0, integer0);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, "");
      Integer integer1 = abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, integer1);
      lRUMap0.entrySet();
      Integer integer2 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer2);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      AbstractHashedMap<Integer, MockFileInputStream> abstractHashedMap1 = new AbstractHashedMap<Integer, MockFileInputStream>();
      AbstractHashedMap<Integer, MockFileInputStream> abstractHashedMap2 = new AbstractHashedMap<Integer, MockFileInputStream>(abstractHashedMap1);
      LRUMap<Integer, MockFileInputStream> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<Integer, MockFileInputStream>(abstractHashedMap2, true);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test57()  throws Throwable  {
      FileSystemHandling.appendLineToFile((EvoSuiteFile) null, (String) null);
      LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object> lRUMap0 = new LRUMap<AbstractLinkedMap.LinkEntry<String, Object>, Object>(581);
      lRUMap0.maxSize();
      LRUMap<InputStream, String> lRUMap1 = new LRUMap<InputStream, String>(2099, 581);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry0 = lRUMap1.header;
      AbstractHashedMap.HashEntry<InputStream, String> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<InputStream, String>(abstractLinkedMap_LinkEntry0, 1601, abstractLinkedMap_LinkEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry1 = new AbstractLinkedMap.LinkEntry<InputStream, String>(abstractHashedMap_HashEntry0, 2099, abstractHashedMap_HashEntry0, (String) null);
      AbstractLinkedMap.LinkEntry<InputStream, String> abstractLinkedMap_LinkEntry2 = abstractLinkedMap_LinkEntry1.after;
      lRUMap1.removeLRU((AbstractLinkedMap.LinkEntry<InputStream, String>) null);
      LRUMap<InputStream, MockFileInputStream> lRUMap2 = new LRUMap<InputStream, MockFileInputStream>();
      LRUMap<InputStream, MockFileInputStream> lRUMap3 = lRUMap2.clone();
      AbstractHashedMap.HashEntry<InputStream, MockFileInputStream> abstractHashedMap_HashEntry1 = new AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>((AbstractHashedMap.HashEntry<InputStream, MockFileInputStream>) null, 581, (Object) null, (MockFileInputStream) null);
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream> abstractLinkedMap_LinkEntry3 = new AbstractLinkedMap.LinkEntry<InputStream, MockFileInputStream>(abstractHashedMap_HashEntry1, 1078, abstractHashedMap_HashEntry0, mockFileInputStream0);
      // Undeclared exception!
      try { 
        lRUMap3.reuseMapping(abstractLinkedMap_LinkEntry3, 792, 2099, mockFileInputStream0, (MockFileInputStream) null);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.next=null, data[removeIndex]=null previous=null key=org.evosuite.runtime.mock.java.io.MockFileInputStream@7cdb584c value=null size=0 maxSize=100 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test58()  throws Throwable  {
      int int0 = 2;
      boolean boolean0 = false;
      LRUMap<String, Object> lRUMap0 = new LRUMap<String, Object>(2, 2, false);
      lRUMap0.loadFactor = (float) 2;
      lRUMap0.maxSize();
      LRUMap<MockFileInputStream, InputStream> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<MockFileInputStream, InputStream>(2, 100, 100, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap initial size must not be greather than max size
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test59()  throws Throwable  {
      LRUMap<Integer, LRUMap<Integer, InputStream>> lRUMap0 = new LRUMap<Integer, LRUMap<Integer, InputStream>>(1, 1, 480.0F);
      LRUMap<Integer, LRUMap<Integer, InputStream>> lRUMap1 = lRUMap0.clone();
      LRUMap<Integer, InputStream> lRUMap2 = new LRUMap<Integer, InputStream>(1073741824, 2620);
      AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>> abstractHashedMap_HashEntry0 = new AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>>((AbstractHashedMap.HashEntry<Integer, LRUMap<Integer, InputStream>>) null, 1, lRUMap1, lRUMap2);
      LRUMap<Integer, InputStream> lRUMap3 = lRUMap2.clone();
      AbstractLinkedMap.LinkEntry<Integer, LRUMap<Integer, InputStream>> abstractLinkedMap_LinkEntry0 = new AbstractLinkedMap.LinkEntry<Integer, LRUMap<Integer, InputStream>>(abstractHashedMap_HashEntry0, 1073741824, lRUMap2, lRUMap3);
      // Undeclared exception!
      try { 
        lRUMap1.moveToMRU(abstractLinkedMap_LinkEntry0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // Entry.before is null. This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test60()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      int int0 = (-1747);
      abstractHashedMap0.get(lRUMap0);
      Integer integer0 = new Integer((-1747));
      Integer integer1 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer1);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      int int1 = 45;
      Integer integer2 = new Integer((-1747));
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), 45, integer0, integer2);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test61()  throws Throwable  {
      int int0 = 807;
      LRUMap<Integer, InputStream> lRUMap0 = new LRUMap<Integer, InputStream>(807, 807);
      LRUMap<Object, Object> lRUMap1 = null;
      try {
        lRUMap1 = new LRUMap<Object, Object>(lRUMap0);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test62()  throws Throwable  {
      LRUMap<Integer, InputStream> lRUMap0 = new LRUMap<Integer, InputStream>(786, 786);
      PipedOutputStream pipedOutputStream0 = new PipedOutputStream();
      lRUMap0.clone();
      BufferedOutputStream bufferedOutputStream0 = new BufferedOutputStream(pipedOutputStream0);
      ObjectOutputStream objectOutputStream0 = new ObjectOutputStream(bufferedOutputStream0);
      lRUMap0.doWriteObject(objectOutputStream0);
      LRUMap<Object, Object> lRUMap1 = new LRUMap<Object, Object>();
      LRUMap<String, InputStream> lRUMap2 = new LRUMap<String, InputStream>(786);
      LRUMap<String, InputStream> lRUMap3 = lRUMap2.clone();
      assertFalse(lRUMap3.isScanUntilRemovable());
      assertEquals(786, lRUMap3.maxSize());
  }

  @Test(timeout = 4000)
  public void test63()  throws Throwable  {
      LRUMap<LRUMap<String, Object>, Integer> lRUMap0 = new LRUMap<LRUMap<String, Object>, Integer>(1520, 1787.77F, true);
      FileSystemHandling.appendStringToFile((EvoSuiteFile) null, (String) null);
      LRUMap<AbstractLinkedMap.LinkEntry<Integer, String>, String> lRUMap1 = new LRUMap<AbstractLinkedMap.LinkEntry<Integer, String>, String>(1520, 1520, 180.12775F, true);
      lRUMap1.isFull();
      LRUMap<MockFileInputStream, Object> lRUMap2 = new LRUMap<MockFileInputStream, Object>(1520, 180.12775F);
      int int0 = 20;
      FileDescriptor fileDescriptor0 = new FileDescriptor();
      MockFileInputStream mockFileInputStream0 = new MockFileInputStream(fileDescriptor0);
      Integer integer0 = new Integer(1520);
      // Undeclared exception!
      try { 
        lRUMap2.reuseMapping((AbstractLinkedMap.LinkEntry<MockFileInputStream, Object>) null, 20, 1190, mockFileInputStream0, integer0);
        fail("Expecting exception: IllegalStateException");
      
      } catch(IllegalStateException e) {
         //
         // NPE, entry=null entryIsHeader=false key=org.evosuite.runtime.mock.java.io.MockFileInputStream@299677f7 value=1520 size=0 maxSize=1520 This should not occur if your keys are immutable, and you have used synchronization properly.
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test64()  throws Throwable  {
      LRUMap<InputStream, Integer> lRUMap0 = new LRUMap<InputStream, Integer>();
      lRUMap0.createValuesIterator();
      lRUMap0.createValuesIterator();
      LRUMap<Object, String> lRUMap1 = new LRUMap<Object, String>(12, false);
      byte[] byteArray0 = new byte[4];
      byteArray0[0] = (byte)20;
      byteArray0[1] = (byte) (-1);
      byteArray0[2] = (byte) (-32);
      byteArray0[3] = (byte)37;
      ByteArrayInputStream byteArrayInputStream0 = new ByteArrayInputStream(byteArray0);
      lRUMap0.put(byteArrayInputStream0, (Integer) null);
      lRUMap1.isFull();
      assertEquals(12, lRUMap1.maxSize());
      assertFalse(lRUMap1.isFull());
      
      lRUMap0.get((Object) "", false);
      assertEquals(100, lRUMap0.maxSize());
      assertFalse(lRUMap0.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test65()  throws Throwable  {
      int int0 = 1854;
      LRUMap<String, Integer> lRUMap0 = new LRUMap<String, Integer>(1854, 1854);
      lRUMap0.init();
      int int1 = 0;
      LRUMap<Integer, Integer> lRUMap1 = new LRUMap<Integer, Integer>(1854, 0);
      lRUMap1.isScanUntilRemovable();
      int int2 = (-2950);
      LRUMap<Integer, String> lRUMap2 = null;
      try {
        lRUMap2 = new LRUMap<Integer, String>((-2950), 1854, 1952.0F, false);
        fail("Expecting exception: IllegalArgumentException");
      
      } catch(IllegalArgumentException e) {
         //
         // LRUMap max size must be greater than 0
         //
         verifyException("org.apache.commons.collections4.map.LRUMap", e);
      }
  }

  @Test(timeout = 4000)
  public void test66()  throws Throwable  {
      LRUMap<Object, String> lRUMap0 = new LRUMap<Object, String>(1520);
      LRUMap<Object, String> lRUMap1 = lRUMap0.clone();
      boolean boolean0 = lRUMap1.isFull();
      assertEquals(1520, lRUMap1.maxSize());
      assertFalse(boolean0);
      assertFalse(lRUMap1.isScanUntilRemovable());
  }

  @Test(timeout = 4000)
  public void test67()  throws Throwable  {
      LRUMap<Object, Integer> lRUMap0 = new LRUMap<Object, Integer>();
      AbstractHashedMap<Object, Integer> abstractHashedMap0 = lRUMap0.clone();
      abstractHashedMap0.get(lRUMap0);
      abstractHashedMap0.put(lRUMap0, (Integer) null);
      Set<Map.Entry<Object, Integer>> set0 = (Set<Map.Entry<Object, Integer>>)lRUMap0.entrySet();
      Integer integer0 = new Integer(116);
      abstractHashedMap0.put(set0, integer0);
      Integer integer1 = new Integer((-1747));
      abstractHashedMap0.put(lRUMap0, integer1);
      LRUMap<Object, Integer> lRUMap1 = new LRUMap<Object, Integer>(abstractHashedMap0, true);
      // Undeclared exception!
      try { 
        lRUMap1.addMapping((-1747), (-1747), (Object) null, (Integer) null);
        fail("Expecting exception: ArrayIndexOutOfBoundsException");
      
      } catch(ArrayIndexOutOfBoundsException e) {
         //
         // -1747
         //
         verifyException("org.apache.commons.collections4.map.AbstractHashedMap", e);
      }
  }
}
